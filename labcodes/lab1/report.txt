Lab1 report
[练习1]

[练习1.1] 操作系统镜像文件 ucore.img 是如何一步一步生成的?(需要比较详细地解释 Makefile 中
每一条相关命令和命令参数的含义,以及说明命令导致的结果)

|生成ucore.img相关代码为：
|# create ucore.img
|UCOREIMG	:= $(call totarget,ucore.img)
|
|$(UCOREIMG): $(kernel) $(bootblock)
|	$(V)dd if=/dev/zero of=$@ count=10000
|	$(V)dd if=$(bootblock) of=$@ conv=notrunc
|	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
|
|生成ucore.img需要先生成kernel和bootblock
|
|生成kernel的makefile相关代码为
|# create kernel target
|kernel = $(call totarget,kernel)
|
|$(kernel): tools/kernel.ld
|
|$(kernel): $(KOBJS)
|	@echo + ld $@
|	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
|	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
|	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' >$(callsymfile,kernel)
|
|为了生成kernel，首先需要 kernel.ld init.o readline.o stdio.o kdebug.o
|	kmonitor.o panic.o clock.o console.o intr.o picirq.o trap.o
|	trapentry.o vectors.o pmm.o  printfmt.o string.o
|
|生成这些.o文件的相关makefile代码为
|	$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,\
|	$(KCFLAGS))
|生成这些.o文件的方法均类似，以init.o为例：
|编译需要init.c
|实际命令为
|	gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 \
|	-gstabs -nostdinc  -fno-stack-protector \
|	-Ilibs/ -Ikern/debug/ -Ikern/driver/ \
|	-Ikern/trap/ -Ikern/mm/ -c kern/init/init.c \
|	-o obj/kern/init/init.o
|生成kernel时，makefile的几条指令中有@前缀的都不必需
|	| 必需的命令只有
|	| ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel \
|	| 	obj/kern/init/init.o obj/kern/libs/readline.o \
|	| 	obj/kern/libs/stdio.o obj/kern/debug/kdebug.o \
|	| 	obj/kern/debug/kmonitor.o obj/kern/debug/panic.o \
|	| 	obj/kern/driver/clock.o obj/kern/driver/console.o \
|	| 	obj/kern/driver/intr.o obj/kern/driver/picirq.o \
|	| 	obj/kern/trap/trap.o obj/kern/trap/trapentry.o \
|	| 	obj/kern/trap/vectors.o obj/kern/mm/pmm.o \
|	| 	obj/libs/printfmt.o obj/libs/string.o
|
|生成bootblock的makefile相关代码为
|# create bootblock
|bootfiles = $(call listf_cc,boot)
|$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))
|
|bootblock = $(call totarget,bootblock)
|
|$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
|	@echo + ld $@
|	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
|	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
|	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
|	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
|
|
|
